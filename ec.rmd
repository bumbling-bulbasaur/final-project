---
title: "Monthly Electric Consumption"
author: "Kevin Eng"
date: "4/28/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(modelr)
library(broom)
library(mixtools)
```

# Introduction

The goal of this analysis is to explore factors which influence electric 
consumption at buildings within New York City. To accomplish this, we collect 
three data sets: one which describes the surrounding weather, one which measures 
a buildings emery consumption, and one which describes the physical 
characteristics of the building.

Ideally, in order to separate electric consumption due to seasonal trends, 
hourly data would have been preferable. Indeed the inductive basis for making
conclusions with high temporal resolution data would be stronger since we would 
not have to worry about confounding with say energy differences due to holidays.
Alas the highest resolution data set that was found was monthly.

# Data

Historical weather data was collected off NOAA's database. Fortunately, they have
a simple API which allows for quick querying of basic weather data. A particular 
aspect of their database is that NOAA only offers access to select daily weather
summaries. Hourly, and monthly averages are only given as ``normal'' averages 
which the NOAA defines as 30-year averages. The observations include daily
minimum temperature, maximum temperature, precipitation, snow fall, and average 
wind speed.

Information on the physical characteristics of a collection of building complexes are
recorded in the NYCHA data set. The data set also contains a number of administrative 
details such as whether or not it is a senior development. In database vernacular 
the primary key of this data set is the TDS number. Since the TDS number refers
to a building complex is it not possible to identify sub-units within a complex.

Details on the monthly energy consumption can be found in the NY open data website.
the website claims the data set only contains readings from 2010 up to March 
2019. This is not quite true since in reality it contains readings up to September 2019.
The monthly readings are given for an individual meter. This means that there
are several readings for a given TDS number since each sub-unit within a complex
has its own meter.


# Data Processing

All three data sets needed some preprocessing in order to get into tidy form.
Since the electric consumption measurements are given on a monthly basis, daily
weather readings must be aggregated into monthly data. This can be accomplished
by extracting the month and and year from each date record using the handy
`year()` and `month()` function from the `lubridate` package. 
Additionally, it would also nice to have some notion of the typical monthly 
temperature. We can estimate this by computing the median of the monthly average
maximum and minimum temperature using purr's `map()` function.

The NYCHA data set contains a great deal of unwanted administrative details. And as 
we will see, the data is also non-tidy as some rows contain multiple observations.
On a somewhat cosmetic level, the  naming convention for the columns is overly 
verbose and makes for cumbersome data referencing. We can easily fix these issues 
using dplyr's `select()` and `rename()` functions. There `TDS` column is somewhat
problematic because it is a source of multiple observations and possible data entry
errors. It likely that some building designs were reused so several apartment building share the same
physical makeup on paper. In regards to possible data entry error, several rows contain `*`'s. To separate
the multiple observations we can use the `separate_row()` function which allows
us to split a row into multiple rows based on a delimiter. The `*`'s can be easily
dealt with using `str_replace()`. The last issue concerns the column that specifies
the number of stories in a complex. Since we do not have the data resolution to
separate sub-units within building complexes we must find a way to reduce the 
number of recorded stories into one value. An easy approach is to take the mean of 
all the stories. This can be accomplished by first splitting the recording using
`str_split` and then using `map_dbl` to produce the mean.

The electric consumption data, like the weather data, provides higher resolution
data then can be used. In order to conform to the NYCHA data, total electric
consumption and costs must be grouped by TDS which can be done 
in a similar fashion as the weather data. Minor data issues were present where
several rows contained missing TDS values. These were easily dropped from the table
using `drop_na`.

Finally all three data sets were merged using `inner_join`'s. The weather
data was joined to the electricity data using the date. Next, the resulting
merged table was joined with the NYCHA data using TDS. Because we used `inner_join`'s
the final table is complete and because we set each table to the same ``scale'' the
final table is tidy.


```{r data-setup, include = FALSE, cache = TRUE}
electric_data <- read_csv("./data/Electric-Consumption.csv")
nycha_data <- read_csv("./data/NYCHA-Development.csv")
weather_data <- read_csv("./data/weather-data.csv")

weather_data %<>% select(-STATION) %>% 
    #calculate median temperature
    mutate(TMED = map2_dbl(TMAX, TMIN, ~ (.x+.y)/2)) %>%
    #extract year and month
    mutate(YEAR = year(DATE), MONTH = month(DATE)) %>%
    group_by(YEAR, MONTH) %>%
    #summarise daily statistics into monthly
    summarise_all(mean, na.rm = TRUE) %>%
    #turn date column to match yyyy-mm-dd format
    mutate(DATE = paste(YEAR,MONTH,"01",sep = "-")) %>%
    mutate(DATE = ymd(DATE)) %>%
    ungroup() %>%
    select(-YEAR, -MONTH)
    
nycha_data %<>% 
    rename(TDS = 'TDS#',
           APTS = 'NUMBER OF CURRENT APARTMENTS',
           TOTAL_POPULATION = 'TOTAL POPULATION',
           STORIES = 'NUMBER OF STORIES',
           STAIRS = 'NUMBER OF STAIRHALLS',
           COMPLETION_DATE = 'COMPLETION DATE',
           BLDG_SQ_FT = 'BLDG COVERAGE SQ FT',
           CUBAGE = 'CUBAGE CU FT') %>%
    select(TDS, DEVELOPMENT, BOROUGH, APTS, TOTAL_POPULATION, 
           STORIES, STAIRS, BLDG_SQ_FT, CUBAGE, COMPLETION_DATE) %>%
    #drop row with missing TDS identifier
    drop_na(TDS) %>% 
    #expand rows with multiple observatios
    separate_rows(TDS, sep = ",") %>%
    #remove non numeric characters
    mutate(TDS = str_remove(.$TDS, "\\*")) %>%
    #convert character string to numeric
    mutate(TDS = parse_number(.$TDS)) %>%
    #convert character string to date
    mutate(COMPLETION_DATE = mdy(.$COMPLETION_DATE)) %>%
    #find average number of stories
    mutate(STORIES = str_split(STORIES, "-")) %>%
    mutate(STORIES = map(STORIES, parse_number)) %>%
    mutate(STORIES = map_dbl(STORIES, mean))

electric_data <- electric_data %>% 
    rename(TDS = 'TDS #', 
           KWH_CONSUMP = 'Consumption (KWH)',
           KWH_CHARGES = 'KWH Charges',
           REVENUE_MONTH = 'Revenue Month') %>%
    #turn monthly revenue into proper date column
    mutate(REVENUE_MONTH = paste0(REVENUE_MONTH,"-01")) %>%
    mutate(REVENUE_MONTH = ymd(REVENUE_MONTH)) %>%
    #remove incomplete months
    filter(KWH_CONSUMP > 0) %>%
    drop_na(TDS) %>%
    group_by(TDS, REVENUE_MONTH) %>%
    #find total KWH consumption for each TDS complex
    summarise(KWH_CONSUMP = sum(KWH_CONSUMP), KWH_CHARGES = sum(KWH_CHARGES)) %>%
    ungroup()
    
full_data <- electric_data %>% 
    inner_join(weather_data, by = c('REVENUE_MONTH' = 'DATE')) %>%
    inner_join(nycha_data, by = 'TDS') 

write_csv(full_data, './data/tidy_electric_data.csv')
```


# Exploratory Data Analysis

To get a rough idea what what annual energy consumption over time looks like, we
group the data by data by year and month and compute the total energy consumption.
From there we can create a plot of super imposed monthly energy consumption 
curves over several years.

```{r electric-trend, results = 'hide', echo=FALSE, out.width = "80%", out.height="50%", fig.align='center', fig.cap = ' '}
full_data %>% 
    group_by(REVENUE_MONTH) %>%
    summarise(KWH_CONSUMP = sum(KWH_CONSUMP)) %>%
    ungroup() %>%
    mutate(YEAR = year(REVENUE_MONTH)) %>%
    mutate(DOY = as.numeric(format(.$REVENUE_MONTH, '%j'))) %>%
    group_by(YEAR) %>%
    filter(KWH_CONSUMP > 5*10^7) %>%
    ggplot(aes(x = DOY, y = KWH_CONSUMP, color = factor(YEAR))) + 
    geom_smooth(se = FALSE, method = 'loess', formula = y ~ x) +
        xlab("Day of Year") +
        ylab("Energy Consumption (KWH)") + 
        labs(color = "Year") + 
        ggtitle("Annual Energy Consumption")
```

The visualization shows a striking amount of variation during the summer months. In an 
optimistic take one might attribute the apparent decrease in electrical consumption
to more energy efficient technologies. Another interesting feature is the magnitude
if the amplitude for each curve. The table below provides an overview between the month with
lowest and highest energy consumption
```{r electric-table, echo = FALSE, fig.cap = ' '}
ratio_data <- full_data %>% 
    group_by(REVENUE_MONTH) %>%
    summarise(KWH_CONSUMP = sum(KWH_CONSUMP)) %>%
    ungroup() %>%
    mutate(YEAR = year(REVENUE_MONTH)) %>%
    mutate(DOY = as.numeric(format(.$REVENUE_MONTH, '%j'))) %>%
    filter(YEAR < 2019) %>%
    group_by(YEAR) %>%
    summarise(MIN_CONSUMP = min(KWH_CONSUMP), MAX_CONSUMP = max(KWH_CONSUMP), 
              RATIO = MAX_CONSUMP / MIN_CONSUMP)

knitr::kable(ratio_data)
```

The ratio indicates there is significant seasonal fluctuation in power consumption.
Likely, the summer months correspond to increased A/C usage. Theoretically,
electric heaters could be used during winter months, but a majority of buildings
use some sort of radiator system. The stark contrast in power consumption makes it
easy to see why, perhaps, during the summer months rolling black outs occur; parts 
of the electric grid could be handling close to twice the load.

The goal is now to investigate the why power consumption fluctuates during the summer.
One avenue of thought is that improving electrical efficiencies of electrical appliances, or better
insulated buildings contribute to fluctuations in summer power consumption. To explore these
ideas we need a normalized metric such as KWH per person from which we can compare its
distribution across the years. And since we are comparing the distribution of power consumption over the years, 
the readings for 2019 should be discarded because it is incomplete. Any estimate of 
the distribution for 2019 will be necessarily screwed due to the missing values. 
```{r electric-dist, echo = FALSE, out.width = "80%", out.height="50%", fig.align='center', fig.cap = ' '}
tmp_df <- full_data %>% 
    mutate(YEAR = year(REVENUE_MONTH)) %>%
    group_by(YEAR, TDS) %>%
    summarise(POPULATION = first(TOTAL_POPULATION), 
              KWH_CONSUMP = sum(KWH_CONSUMP),
              MEAN_CONSUMP = KWH_CONSUMP/POPULATION) %>%
    group_by(YEAR) %>%
    summarise(MEAN_TOTAL = mean(MEAN_CONSUMP)) %>% 
    filter(YEAR < 2019)

mean_power <- full_data %>% 
    mutate(YEAR = year(REVENUE_MONTH)) %>%
    group_by(YEAR, TDS) %>%
    summarise(POPULATION = first(TOTAL_POPULATION), 
              KWH_CONSUMP = sum(KWH_CONSUMP),
              MEAN_CONSUMP = KWH_CONSUMP/POPULATION) %>%
    filter(YEAR < 2019)

mean_power %>% ggplot(aes(MEAN_CONSUMP)) + 
        geom_density() +
        geom_vline(data = tmp_df, aes(xintercept = MEAN_TOTAL, color = 'red')) + 
        facet_wrap(vars(factor(YEAR))) + 
        xlab("Mean Consumption (KWH / Person)") +
        ylab("Density") + 
        ggtitle("Distribution of Mean Power Consumption") +
        labs(color = "Mean")
```

The apparent bi-modal nature of the distributions is a bit perplexing as there is 
no obvious reason for it. A casual glance at the overall shape of the distributions
suggests that a Gaussian mixture model may be useful in breaking down the distribution
into two groups. For simplicity we choose a Gaussian mixture model with two clusters 
which we can estimate using `normalmixEM` from the `mixtools` package. 
The `modelr` package allows us to easily group each model; by using `nest()` we can
associate each year with a particular mixture model estimate. Figure ? shows
each mixture model estimate super imposed on top of the non parametric density 
estimate. From the mismatch, we can see our data has lighter tails resulting
in taller peaks, but the estimated models seem perfectly adequate for exploratory 
purposes so we proceed with using it.
```{r mixture-setup, include = FALSE}
#generate tibble with mixture model information

mixture_model <- function(data) {
    mm_model <- normalmixEM(data$MEAN_CONSUMP, lambda = .5, mu = c(1000, 3500), sigma = c(200,1000))
}

mixture_est <- function(mm_model) {
    tibble(term = c("mu", "sigma"), 
        comp_1 = c(mm_model$mu[1],mm_model$sigma[1]), 
        comp_2 = c(mm_model$mu[2],mm_model$sigma[2]))
}

mixture_prob <- function(mm_model) {
        tibble(class_prob = mm_model$posterior[,1])
}

density_values <- function(mm_model) {
    tlow <- tibble(MEAN_CONSUMP = seq(0,8200, by = 1), 
            y = mm_model$lambda[1] * dnorm(MEAN_CONSUMP, mean = mm_model$mu[1], sd = mm_model$sigma[1]),
            class = "low")
    thigh <- tibble(MEAN_CONSUMP = seq(0,8200, by = 1), 
            y = mm_model$lambda[2] * dnorm(MEAN_CONSUMP, mean = mm_model$mu[2], sd = mm_model$sigma[2]),
            class = "high")
    rbind(tlow,thigh)
}

mm_data <- mean_power %>% 
    group_by(YEAR) %>%
    nest() %>%
    mutate(model = map(data, mixture_model)) %>%
    mutate(est = map(model, mixture_est)) %>%
    mutate(prob = map(model, mixture_prob)) %>%
    mutate(density = map(model, density_values))
```


```{r mixture-fit, echo = FALSE, out.width = "80%", out.height="50%", fig.align='center', fig.cap = ' '}
density_data <- mm_data %>%
    select(YEAR,data,density) %>%
    unnest(density)

ggplot(mean_power, aes(MEAN_CONSUMP)) +
    geom_density() +
    geom_path(data = density_data, aes(MEAN_CONSUMP,y,color=class)) +
    facet_wrap(vars(factor(YEAR))) +
    xlab("Mean Consumption (KWH / Person)") +
    ylab("Density") + 
    ggtitle("Distribution of Mean Power Consumption") +
    labs(color = "Class")
```
Figure ? is a table of the numeric estimates for the parameters for each
Gaussian mixture model. The difference between the estimated means for the first
and second component is in the ball park of 2500 KWH. This is a rather stunning
conclusion as it implies some New Yorker's use twice as much electricity!
```{r mixture-est, echo = FALSE} 
mm_data %>% 
    unnest(est) %>%
    select(YEAR, term, comp_1, comp_2) %>%
    pivot_wider(names_from = term, values_from = c(comp_1,comp_2)) %>%
    knitr::kable()
```

\pagebreak

Since we have calculated mean power consumption by grouping
on TDS, it stands to reason that there are specific building characteristics which
support more efficient use of electricity. A reasonable starting hypothesis is
to suppose that new building are more energy efficient. Material science has done
much in the last half century, and modern insulation and building techniques used
today are noticeably superior. Figure ? is a density estimate of the distribution
of building completion dates. There is a noticeable bump in the mid 1980's where 
there was a surge of new constructions.
```{r date-dist, echo = FALSE, out.width = "60%", out.height="40%", fig.align='center', fig.cap = ' '}
nycha_data %>% 
    drop_na(COMPLETION_DATE) %>% 
    ggplot(aes(COMPLETION_DATE)) + 
        geom_density() +
        ggtitle("Distribution of Building Completion Dates") +
        xlab("Completion Date") +
        ylab("Density")
```

Figure 5 indicates that our guess isn't quite right, but we aren't completely wrong
either. The significant overlap between high and lower power users even among 
newer construction suggest building age itself is not enough the explain the difference
in energy consumption. However there is a noticeable pattern that newer building tend
to be more energy efficient. Overall it would seem that there is some characteristic
newer buildings tend to have, but which older buildings can also have which save
on electrical cost.

```{r cluster-plot, warning = FALSE, message = FALSE, echo = FALSE, out.width = "60%", out.height="40%", fig.align='center', fig.cap = ' ', fig.pos="h"}
mm_data %>%
    unnest(c(data, prob)) %>%
    select(-model, -est, -density) %>%
    left_join(nycha_data, by = "TDS") %>%
    mutate(CLASS = ifelse(class_prob > .5, "low", "high")) %>%
    ggplot(aes(COMPLETION_DATE, MEAN_CONSUMP, color = CLASS)) +
        geom_point() +
        xlab("Completion Date") +
        ylab("Mean Consumption (KWH)") +
        ggtitle("Cluster of Mean Consumption vs Completion Date")
```


Next we turn our attention to the weather data. An interesting question is whether not it supports
the notion of seasons arriving "late" or "early". In other words, we want to see
whether or not ground hogs should be afraid of their shadow. We can investigate
this claim by exploring how temperature varies year to year. Using `pivot_longer`
we can gather all the temperature readings into one column. This allows us to use
ggplot2's facet wrap feature to quickly juxtapose multiple different temperature readings.
In figure 2, a derived metric `TDIF` is included which measured the temperature gap between
`TMAX` and `TMIN`. Unfortunately for ground hogs everywhere, figure 2 does not support 
the notion that seasons (at least when observed from a temperature stand point) do
not arrive early or late. In fact, it would seem that on average, monthly temperatures are
very regular since they only differ by a couple of degrees year to year. However
the story is not quite complete because the the `TDIF` graph provides some reason
why people believe seasons sometimes don't arrive on time. It may not be a coincidence after all
that ground hogs day is a statement about whether or not spring comes early or not.
`TDIF` reveals that, by far, the the biggest temperature swings come around late
spring (i.e. day 100 - 150) with differences sometimes over 18 degrees. With such a
high variance in temperature, it would come as no surprise that some people find it hard
to tell when winter ends and spring begins.

```{r, results = 'hide', echo=FALSE, out.width = "80%", out.height="40%", fig.align='center', fig.cap = ' '}
weather_data %>% 
    mutate(YEAR = year(DATE)) %>% 
    mutate(DOY = as.numeric(format(.$DATE, '%j'))) %>%
    mutate(TDIF = TMAX - TMIN) %>%
    pivot_longer(c(TMAX,TMIN, TDIF), names_to = "T_TYPE", values_to = "TEMP" ) %>%
    ggplot(aes(x=DOY,y=TEMP, color = factor(YEAR))) + 
        geom_path() + 
        facet_wrap(vars(factor(T_TYPE)), scale = 'free') +
        xlab("Day of the Year") + 
        ylab("Temperature(F)") + 
        labs(color = "Year") + 
        ggtitle("Temperature Statistics over Time")

```


To more precisely quantify the effects of temperature we can apply a mixed model
type analysis. The linear model itself will be simple:
\[
    \text{KWH Consumption} = \beta_0 + \beta_1 \cdot \text{TMAX}.
\]
Here $\beta_0$ and $\beta_1$ are random and associated with an individual TDS.

```{r, echo = FALSE}
consumption_model <- function(data) {
    lm(MEAN_CONSUMP ~ TMAX, data = data)
}

class_df <- mm_data %>%
    unnest(c(data, prob)) %>%
    select(-model, -est, -density) %>%
    mutate(CLASS = ifelse(class_prob > .5, "low", "high")) %>%
    ungroup() %>%
    select(TDS, CLASS) %>%
    distinct()
   
full_data %>% 
    group_by(TDS) %>%
    mutate(MEAN_CONSUMP = KWH_CONSUMP / TOTAL_POPULATION) %>%
    nest() %>%
    mutate(model = map(data, consumption_model)) %>%
    mutate(summary = map(model, tidy)) %>% 
    unnest(summary) %>%
    left_join(class_df, by = "TDS") %>%
    ggplot(aes(estimate)) + 
        geom_density() +
        facet_wrap(vars(factor(term), factor(CLASS)), scales = 'free')
``` 

